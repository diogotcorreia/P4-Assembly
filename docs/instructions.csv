ORIG;ORIG <endereço>;permite especificar no campo <endereço> a primeira posição de memória em que um bloco de programa ou dados é carregado em memória. Este comando pode aparecer várias vezes no código, permitindo que se definam blocos em diferentes zonas de memória.;;TRUE;;;
EQU;<símbolo> EQU <const>;permite associar um valor const a um símbolo. Convenciona-se que estes símbolos são palavras todas em maiúsculas, com uso possível do caracter de separação;;TRUE;;;
WORD;<etiqueta> WORD <const>;permite reservar uma posição de memória para conter uma variável do programa assembly, associando a essa posição o nome especificado em <etiqueta>. O campo  const indica o valor a que essa posição de memória deve ser inicializada. Convenciona-se que estas etiquetas são palavras capitalizadas todas juntas: primeira letra de cada palavra em maiúsculas e restantes em minúsculas, por exemplo CicloInterno;;TRUE;;;
STR;<etiqueta> STR <texto>|<const>[,<texto>|<const>];coloca em posições de memória consecutivas o texto que estiver entre plicas ou o valor de <const> No caso de <texto> , o código ASCII de cada caracter entre plicas fica numa posição de memória (portanto usa tantas posições de memória quantos os caracteres em <texto>). Podem-se usar mais do que um parâmetro, separados por vírgulas, sendo feita a sua concatenação em memória. <etiqueta> fica com o endereço do primeiro caracter. A convenção para os nomes destas etiquetas é o mesmo que para WORD.;;TRUE;;;
TAB;<etiqueta> TAB <const>;reserva o número de posições de memória especificados no campo <const> sem as inicializar com qualquer valor. <etiqueta> fica com o endereço da primeira posição. A convenção para os nomes destas etiquetas é o mesmo que para WORD e STR.;;TRUE;;;
ADD;ADD op1, op2;op1←op1 + op2, soma a op1 o valor de op2.;ZCNO;FALSE;;;
ADDC;ADDC op1, op2;op1←op1 + op2 + C, igual a ADD excepto que soma mais um caso o bit de estado transporte esteja a 1.;ZCNO;FALSE;;;
AND;AND op1, op2;op1←op1 ∧ op2. Faz o AND lógico bit-a-bit dos dois operandos.;ZN;FALSE;;;
BR;BR <deslocamento>;PC ← PC + <deslocamento>, branch, salto relativo incondicional para <deslocamento> posições de memória à frente (ou atrás, se <deslocamento> for negativo) da posição actual. O valor de <deslocamento> tem que estar compreendido entre -32 e 31. Normalmente <deslocamento> é especificado com uma etiqueta.;;FALSE;;;
BR.cond;BR.cond <deslocamento>;salto relativo condicional baseado no valor de um dada condição. As versões disponíveis são BR.C, BR.NC, BR.NN, BR.O, BR.NO, BR.Z, BR.NZ, BR.I, BR.NI, BR.P e BR.NP, onde C, N, O e Z designam as respetivas flags, I interrupção, P positivo e o prefixo N a negação do valor. Caso a condição se verifique, a próxima instrução a ser executada será a do endereço PC + <deslocamento> (PC ← PC + <deslocamento>). Caso contrário, funciona como um NOP O valor de <deslocamento> tem que estar compreendido entre -32 e 31. Normalmente <deslocamento> é especificado com uma etiqueta.;;FALSE;;;
CALL;CALL <endereço>;M[SP] ← PC, SP ← SP - 1, PC ← <endereço>, chamada a subrotina com início em <endereço> O endereço da instrução seguinte ao CALL é colocado na pilha e é feito uma salto para a subrotina. Normalmente <endereço> é especificado com uma etiqueta.;;FALSE;;;
CALL.cond;CALL.cond <endereço>;chamada condicional a uma subrotina baseado no valor de um dado bit de estado. As versões disponíveis são BR.C, BR.NC, BR.NN, BR.O, BR.NO, BR.Z, BR.NZ, BR.I, BR.NI, BR.P e BR.NP, onde C, N, O e Z designam as respetivas flags, I interrupção, P positivo e o prefixo N a negação do valor. Caso a condição se verifique, comporta-se como uma instrução CALL. Caso contrário, funciona como um NOP. Normalmente <endereço> é especificado com uma etiqueta.;;FALSE;;;
CLC;CLC;clear C, coloca o bit de estado transporte a 0.;C;FALSE;;;
CMC;CMC;complementa o valor do bit de estado transporte.;C;FALSE;;;
CMP;CMP op1, op2;compara os operandos op1 e op2, actualizando os bits de estado. Efectua a mesma operação que SUB op1, op2 sem alterar nenhum dos operandos. É habitualmente seguida no programa por uma instrução BR. cond, JMP. cond ou CALL. Cond;ZCNO;FALSE;;;
COM;COM op;op←¬op, faz o complemento bit-a-bit de op.;ZN;FALSE;;;
DEC;DEC op;op←op - 1, decrementa op em uma unidade.;ZCNO;FALSE;;;
DIV;DIV op1, op2;executa a divisão inteira de op1 por op2, deixando o resultado em op1 e o resto em op2. Assume operandos sem sinal. O bit de estado O fica a 1 no caso de divisão por 0. Os bit de estado C e N ficam sempre a 0. Uma vez que ambos os operandos são usados para guardar o resultado, nenhum deles pode estar no modo imediato. Pela mesma razão, os dois operandos não devem ser o mesmo pois parte do resultado será perdido.;ZCNO;FALSE;;;
DSI;DSI;disable interrupts, coloca o bit de estado E a 0, inibindo assim as interrupções.;E;FALSE;;;
ENI;ENI;enable interrupts, coloca o bit de estado E a 1, permitindo assim as interrupções.;E;FALSE;;;
INC;INC op;op←op + 1, incrementa op em uma unidade.;ZCNO;FALSE;;;
INT;INT const;M[SP]←RE, SP←SP - 1, M[SP]←PC, SP←SP - 1, RE←0, PC←M[FE00h+const], gera uma interrupção com o vector const Este vector tem que estar compreendido entre 0 e 255. Esta interrupção ocorre sempre, independentemente do valor do bit de estado E, enable interrupts.;EZCNO;FALSE;;;
JMP;JMP <endereço>;PC←<endereço>, jump, salto absoluto incondicional para a posição de memória com o valor <endereço> Normalmente <endereço> é especificado com uma etiqueta.;;FALSE;;;
JMP.cond;JMP. cond <endereço>;salto relativo condicional baseado no valor de um dada condição. As versões disponíveis são JMP.C, JMP.NC, JMP.NN, JMP.O, JMP.NO, JMP.Z, JMP.NZ, JMP.I, JMP.NI, JMP.P e JMP.NP, onde C, N, O e Z designam as respetivas flags, I interrupção, P positivo e o prefixo N a negação do valor. Caso a condição se verifique, a próxima instrução a ser executada será a apontada por <endereço> (PC ← <endereço>). Caso contrário, funciona como um NOP Normalmente <endereço> é especificado com uma etiqueta.;;FALSE;;;
MOV;MOV op1, op2;op1←op2, copia o conteúdo de op2 para op1;;FALSE;;;
MUL;MUL op1, op2;op1|op2 ← op1 × op2, multiplica op1 por op2 , assumindo-os como números sem sinal. Como o resultado necessita de 32 bits são usados os dois operandos para o guardar: op1 fica com o 16 mais significativos e op2 com os 16 menos significativos. O bit de estado Z é actualizado de acordo com o resultado, os restantes ficam a 0. Uma vez que ambos os operandos são usados para guardar o resultado, nenhum deles pode estar no modo imediato. Pela mesma razão, os dois operandos não devem ser o mesmo pois parte do resultado será perdido.;;FALSE;;;
MVBH;MVBH op1, op2;op1 ← (op1 ∧ 00FFh) ∨ (op2 ∧ FF00h), copia o octeto de maior peso de op2 para o octeto de maior peso de op1;;FALSE;;;
MVBL;MVBL op1, op2;op1 ← (op1 ∧ FF00h) ∨ (op2 ∧ 00FFh), copia o octeto de menor peso de op2 para o octeto de menor peso de op1;;FALSE;;;
NEG;NEG op;op←-op, troca o sinal (complemento para 2) do operando op.;ZCNO;FALSE;;;
NOP;NOP;no operation, não altera nada.;;FALSE;;;
OR;OR op1, op2;op1←op1 ∨ op2, faz o OR lógico bit-a-bit dos dois operandos.;ZN;FALSE;;;
POP;POP op;SP←SP + 1, op←M[SP], copia o valor do topo da pilha para op e reduz o tamanho desta.;;FALSE;;;
PUSH;PUSH op;M[SP]←op, SP←SP - 1, coloca op no topo da pilha.;;FALSE;;;
RET;RET;SP←SP + 1, PC←M[SP], retorna de uma subrotina. O endereço de retorno é obtido do topo da pilha.;;FALSE;;;
RETN;RETN const;SP ← SP + 1, PC ← M[SP], SP ← SP + const, retorna de uma subrotina libertando const posições do topo da pilha. Esta instrução permite retornar de uma subrotina retirando automaticamente parâmetros que tenham sido passados para essa subrotina através da pilha. O valor de const tem que estar compreendido entre 0 e 1023 (10 bits).;;FALSE;;;
ROL;ROL op, const;rotate left, faz a rotação à esquerda dos bits de op o número de vezes indicado porconst Mesma operação que o deslocamento simples,SHL , mas os bits da esquerda não se perdem, sendo colocados nas posições mais à direita de op O valor de const tem que estar compreendido entre 1 e 16.;ZCN;FALSE;;;
ROLC;ROLC op, const;rotate left with carry, mesma operação que ROL , mas envolvendo o bit de estado transporte: o valor de C é colocado na posição mais à direita de op e o bit mais à esquerda de op é colocado em C. O valor de const tem que estar compreendido entre 1 e 16.;ZCN;FALSE;;;
ROR;ROR op, const;rotate right, faz a rotação à direita dos bits de op o número de vezes indicado por const Mesma operação que o deslocamento simples, SHR , mas os bits da direita não se perdem, sendo colocados nas posições mais à esquerda de op O valor de const tem que estar compreendido entre 1 e 16.;ZCN;FALSE;;;
RORC;RORC op, const;rotate right with carry, mesma operação que ROR , mas envolvendo o bit de estado transporte: o valor de C é colocado na posição mais à esquerda de op e o bit mais à direita de op é colocado em C. O valor de const tem que estar compreendido entre 1 e 16.;ZCN;FALSE;;;
RTI;RTI;SP ← SP + 1, PC ← M[SP], SP ← SP + 1, RE ← M[SP], return from interrupt, retorna de uma rotina de serviço a uma interrupção. O endereço de retorno e os bits de estado são obtidos do topo da pilha, por esta ordem.;EZCNO;FALSE;;;
SHL;SHL op, const;shift left, deslocamento à esquerda dos bits de op o número de vezes indicado por const Os bits mais à esquerda de op são perdidos e é colocado 0 nas posições mais à direita. O bit de estado transporte fica com o valor do último bit perdido. O valor de const tem que estar compreendido entre 1 e 16.;ZCN;FALSE;;;
SHLA;SHLA op, const;shift left arithmetic, mesma operação que SHL , mas actualizando os bits de estado correspondentes às operações aritméticas. Permite realizar de forma expedita uma multiplicação de op por 2n. O valor de const tem que estar compreendido entre 1 e 16.;ZCNO;FALSE;;;
SHR;SHR op, const;shift right, deslocamento à direita dos bits de op o número de vezes indicado por const Os bits mais à direita de op são perdidos e são colocados 0 nas posições mais à esquerda. O bit de estado transporte fica com o valor do último bit perdido. O valor de const tem que estar compreendido entre 1 e 16.;ZCN;FALSE;;;
SHRA;SHRA op, const;shift right arithmetic, deslocamento à direita dos bits de op , mas mantendo o bit de sinal. Os bits mais à direita de op são perdidos, mas os bits mais à esquerda mantêm o valor anterior. O bit de estado transporte fica com o valor do último bit perdido. Permite realizar de forma expedita uma divisão de op por 2n. const entre 1 e 16.;ZCNO;FALSE;;;
STC;STC;set C, coloca o bit de estado transporte a 1.;C;FALSE;;;
SUB;SUB op1, op2;op1←op1 - op2, subtrai a op1 o valor de op2.;ZCNO;FALSE;;;
SUBB;SUBB op1, op2;op1 ← op1 - op2 - ¬C, igual a SUB excepto que subtrai mais um caso o bit de estado transporte esteja a 1.;ZCNO;FALSE;;;
TEST;TEST op1, op2;testa o bits dos operandos op1 e op2, actualizando os bits de estado. Efectua a mesma operação que AND op1, op2 sem alterar nenhum dos operandos.;ZN;FALSE;;;
XCH;XCH op1, op2;exchange op1/op2, op1←op2, op2←op1, troca os valores de op1 e op2;;FALSE;;;
XOR;XOR op1, op2;op1←op1 ⊕ op2. Faz a operação lógica EXCLUSIVE-OR bit-a-bit dos dois operandos.;ZN;FALSE;;;
